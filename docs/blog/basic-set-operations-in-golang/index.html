<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- META TAGS -->
    <meta charset="utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="keywords" content="blog, programming" />
    <meta
      name="description"
      content="As an abstract data type, sets are a missing feature in the Go language. But can be easily implemented using maps."
    />
    <meta name="language" content="en-US" />
    <meta name="author" content="Rodolfo Mói, rodmoi.oliveira@gmail.com" />
    <meta name="designer" content="Rodolfo Mói" />
    <meta name="copyright" content="Rodolfo Mói" />
    <meta name="reply-to" content="rodmoi.oliveira@gmail.com" />
    <meta name="owner" content="Rodolfo Mói" />
    <meta
      name="url"
      content="https://rm-o.netlify.app/basic-set-operations-in-golang"
    />
    <meta name="date" content="2021-11-23" />
    <meta name="coverage" content="Worldwide" />
    <meta name="distribution" content="Global" />
    <meta name="rating" content="General" />
    <meta http-equiv="Expires" content="0" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Cache-Control" content="no-cache" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <!-- OG AND TWITTER META TAGS -->
    <meta property="og:type" content="page" />
    <meta
      property="og:url"
      content="https://rm-o.netlify.app/basic-set-operations-in-golang"
    />
    <meta property="og:title" content="Basic set operations in golang" />
    <meta
      property="og:image"
      content="https://rm-o.netlify.app/images/ryoji-iwata-DZ5qYLvWsHw-unsplash.jpg"
    />
    <meta
      property="og:description"
      content="As an abstract data type, sets are a missing feature in the Go language. But can be easily implemented using maps."
    />
    <meta property="article:author" content="Rodolfo Mói" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@rodmoi" />
    <meta name="twitter:title" content="Basic set operations in golang" />
    <meta name="twitter:creator" content="@rodmoi" />
    <meta
      name="twitter:description"
      content="As an abstract data type, sets are a missing feature in the Go language. But can be easily implemented using maps."
    />
    <title>Basic set operations in golang</title>
    <!-- STYLES -->

    <link href="/fonts.css" rel="stylesheet" media="all" />

    <link rel="stylesheet" href="/style.css" media="all" />
  </head>
  <body id="body" data-theme="light">
    <header class="header">
      <h1 class="header__title">
        <a class="header__link" href="/">rm-o</a>
      </h1>
      <button class="header__btn" id="theme">dark</button>
    </header>

    <script>
      const theme = localStorage.getItem("rodolfo-blog-theme");
      if (theme === "dark") {
        const btn = document.getElementById("theme");
        const body = document.getElementById("body");
        body.setAttribute("data-theme", "dark");
        btn.innerText = "light";
      }
    </script>

    <link
      rel="stylesheet"
      href="/katex/contrib/copy-tex.css"
      rel="stylesheet"
      type="text/css"
    />
    <link
      rel="stylesheet"
      href="/katex/katex.min.css"
      integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs"
      crossorigin="anonymous"
    />

    <article class="post">
      <h2 class="post__title">Basic set operations in Golang</h2>
      <p class="post__date">&#8226;&nbsp;2021-11-23&nbsp;&#8226;</p>
      <p class="mark__start">&ctdot;</p>

      <section class="toc">
        <p class="toc__title">Table of Content:</p>
        <ul class="toc__ul">
          <li class="toc__li">
            <a
              class="toc__anchor"
              href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#what-are-sets"
              >What are sets?</a
            >
          </li>

          <li class="toc__li">
            <a
              class="toc__anchor"
              href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#abstract-data-type"
              >Abstract Data Type</a
            >
          </li>

          <li class="toc__li">
            <a
              class="toc__anchor"
              href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#basic-set-operations"
              >Basic set operations</a
            >

            <ul class="toc__ul">
              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#membership"
                  >Membership</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#union"
                  >Union</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#intersection"
                  >Intersection</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#difference-and-complement"
                  >Difference and Complement</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#symmetric-difference"
                  >Symmetric Difference</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#subset"
                  >Subset</a
                >
              </li>
            </ul>
          </li>

          <li class="toc__li">
            <a
              class="toc__anchor"
              href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#set-identities"
              >Set Identities</a
            >

            <ul class="toc__ul">
              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#antisymmetric"
                  >Antisymmetric</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#associative"
                  >Associative</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#commutative"
                  >Commutative</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#complement"
                  >Complement</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#de-morgan-s-laws"
                  >De Morgan&#x27;s Laws</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#distributive"
                  >Distributive</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#double-complement"
                  >Double Complement</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#idempotent"
                  >Idempotent</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#identity"
                  >Identity</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#transitive"
                  >Transitive</a
                >
              </li>
            </ul>
          </li>

          <li class="toc__li">
            <a
              class="toc__anchor"
              href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#counting-bit-sequences"
              >Counting bit sequences</a
            >

            <ul class="toc__ul">
              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#cardinality"
                  >Cardinality</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#product-of-sets"
                  >Product of sets</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#power-set"
                  >Power Set</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#bijection"
                  >Bijection</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#counting-subsets-of-a-finite-set"
                  >Counting subsets of a finite set</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#bit-sets"
                  >Bit sets</a
                >
              </li>

              <li class="toc__li">
                <a
                  class="toc__anchor"
                  href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#working-together"
                  >Working together</a
                >
              </li>
            </ul>
          </li>

          <li class="toc__li">
            <a
              class="toc__anchor"
              href="https://rm-o.netlify.app/blog/basic-set-operations-in-golang/#references"
              >References</a
            >
          </li>
        </ul>
      </section>

      <h3 id="what-are-sets">What are sets?</h3>
      <p>
        In mathematics, a set is a collection of unique and unsorted elements.
        The conventional way to write down a set is to list the elements inside
        curly braces, like this \( \{ 1,2,3 \} \). The elements inside a set
        should only appear once, because any element is either in the set or
        not. This means that the sets \( \{ \text{dog}, \text{dog}, \text{cat}
        \} \) and \( \{ \text{dog}, \text{cat} \} \) are equal. Also, the order
        of the elements inside a set is meaningless, so \( \{ a,b,c \} \) and \(
        \{ c,b,a \} \) are the same set written in two different ways.
      </p>
      <p>
        Sets are a fundamental mathematical construct and serve as a handy data
        structure when writing computer programs. Some languages implement sets
        by default. But in others, like Go, you have to implement yourself.
      </p>
      <h3 id="abstract-data-type">Abstract Data Type</h3>
      <p>
        As an
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://en.wikipedia.org/wiki/Abstract_data_type"
          >abstract data type</a
        >, sets are a missing feature in the Go language. However they can be
        easily implemented by using
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://tour.golang.org/moretypes/19"
          >maps</a
        >. Let's implement the <code>Set</code> type with three methods:
        <code>MakeSet</code> to create new sets, <code>Size</code> to get the
        set's cardinality and, <code>ToString</code> to print its string
        representation:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#b48ead;">package </span><span style="color:#bf616a;">main
</span><span>
</span><span style="color:#b48ead;">import </span><span>(
</span><span>	&quot;</span><span style="color:#a3be8c;">fmt</span><span>&quot;
</span><span>	&quot;</span><span style="color:#a3be8c;">strings</span><span>&quot;
</span><span>)
</span><span>
</span><span style="color:#b48ead;">type </span><span>(
</span><span>	SetItem    </span><span style="color:#b48ead;">interface</span><span>{}
</span><span>	SetSlice   []</span><span style="color:#b48ead;">SetItem
</span><span>	Set        </span><span style="color:#b48ead;">map</span><span>[</span><span style="color:#b48ead;">SetItem</span><span>]</span><span style="color:#b48ead;">membership
</span><span>	membership </span><span style="color:#b48ead;">struct</span><span>{}
</span><span>)
</span><span>
</span><span style="color:#b48ead;">func </span><span style="color:#8fa1b3;">MakeSet</span><span>(</span><span style="color:#bf616a;">si </span><span>...</span><span style="color:#b48ead;">SetItem</span><span>) (</span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">Set</span><span>) {
</span><span>	</span><span style="color:#bf616a;">s </span><span>= </span><span style="color:#96b5b4;">make</span><span>(</span><span style="color:#b48ead;">map</span><span>[</span><span style="color:#b48ead;">SetItem</span><span>]</span><span style="color:#b48ead;">membership</span><span>)
</span><span>
</span><span>	</span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">_</span><span>, </span><span style="color:#bf616a;">v </span><span>:= </span><span style="color:#b48ead;">range </span><span style="color:#bf616a;">si </span><span>{
</span><span>		</span><span style="color:#bf616a;">s</span><span>[</span><span style="color:#bf616a;">v</span><span>] = </span><span style="color:#bf616a;">membership</span><span>{}
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#b48ead;">return
</span><span>}
</span><span>
</span><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">Set</span><span>) </span><span style="color:#8fa1b3;">Size</span><span>() </span><span style="color:#b48ead;">int </span><span>{
</span><span>	</span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">len</span><span>(</span><span style="color:#bf616a;">s</span><span>)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">Set</span><span>) </span><span style="color:#8fa1b3;">ToString</span><span>() </span><span style="color:#b48ead;">string </span><span>{
</span><span>	</span><span style="color:#bf616a;">r </span><span>:= </span><span style="color:#96b5b4;">make</span><span>([]</span><span style="color:#b48ead;">string</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">s</span><span>.</span><span style="color:#bf616a;">Size</span><span>())
</span><span>
</span><span>	</span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">k </span><span>:= </span><span style="color:#b48ead;">range </span><span style="color:#bf616a;">s </span><span>{
</span><span>		</span><span style="color:#bf616a;">r </span><span>= </span><span style="color:#96b5b4;">append</span><span>(</span><span style="color:#bf616a;">r</span><span>, </span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Sprintf</span><span>(&quot;</span><span style="color:#d08770;">%v</span><span>&quot;, </span><span style="color:#bf616a;">k</span><span>))
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Sprintf</span><span>(&quot;</span><span style="color:#a3be8c;">{</span><span style="color:#d08770;">%v</span><span style="color:#a3be8c;">}</span><span>&quot;, </span><span style="color:#bf616a;">strings</span><span>.</span><span style="color:#bf616a;">Join</span><span>(</span><span style="color:#bf616a;">r</span><span>, &quot;</span><span style="color:#a3be8c;">,</span><span>&quot;))
</span><span>}
</span></code></pre>
      <p>
        Now that we have a minimal implementation for the <code>Set</code> type,
        we can create a new set and print its elements like this:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#bf616a;">set </span><span>:= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">frog</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">cow</span><span>&quot;)
</span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Println</span><span>(</span><span style="color:#bf616a;">set</span><span>.</span><span style="color:#bf616a;">ToString</span><span>()) </span><span style="color:#65737e;">// {frog,dog,cow,cat}
</span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Println</span><span>(</span><span style="color:#bf616a;">set</span><span>.</span><span style="color:#bf616a;">ToString</span><span>()) </span><span style="color:#65737e;">// {dog,cow,cat,frog}
</span></code></pre>
      <p>
        As you can see, all the duplicate elements were removed from the set,
        and its elements were printed out inside curly braces in arbitrary
        order.
      </p>
      <h3 id="basic-set-operations">Basic set operations</h3>
      <p>
        We'll implement some basic set operations in Golang, like
        <strong>membership</strong> assertion, <strong>union</strong>,
        <strong>intersection</strong>, <strong>difference</strong>,
        <strong>symmetric difference</strong>, and
        <strong>subset</strong> assertion. Along the way, we'll provide the
        mathematical definition for each one of those operations to better
        understand them.
      </p>
      <h4 id="membership">Membership</h4>
      <p>
        The most simple set operation is to assert element membership. The
        expression \( e \in A \) asserts that \(e\) is an element of the set
        \(A\). The expression \(y \notin A \) means that \(y\) is not an element
        of the set \(A\). Let's write a method called <code>Contains</code> for
        the <code>Set</code> type to verify if any given element belongs to it:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">Set</span><span>) </span><span style="color:#8fa1b3;">Contains</span><span>(</span><span style="color:#bf616a;">si </span><span style="color:#b48ead;">SetItem</span><span>) (</span><span style="color:#bf616a;">ok </span><span style="color:#b48ead;">bool</span><span>) {
</span><span>	</span><span style="color:#bf616a;">_</span><span>, </span><span style="color:#bf616a;">ok </span><span>= </span><span style="color:#bf616a;">s</span><span>[</span><span style="color:#bf616a;">si</span><span>]
</span><span>
</span><span>	</span><span style="color:#b48ead;">return
</span><span>}
</span></code></pre>
      <p>Now let's build a new set and test for membership:</p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#bf616a;">set </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">cow</span><span>&quot;)
</span><span>
</span><span style="color:#bf616a;">ok </span><span>:= </span><span style="color:#bf616a;">set</span><span>.</span><span style="color:#bf616a;">Contains</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;)
</span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Println</span><span>(</span><span style="color:#bf616a;">ok</span><span>) </span><span style="color:#65737e;">// true
</span><span>
</span><span style="color:#bf616a;">ok </span><span>= </span><span style="color:#bf616a;">set</span><span>.</span><span style="color:#bf616a;">Contains</span><span>(&quot;</span><span style="color:#a3be8c;">buffalo</span><span>&quot;)
</span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Println</span><span>(</span><span style="color:#bf616a;">ok</span><span>) </span><span style="color:#65737e;">// false
</span></code></pre>
      <p>Easy peasy, let's continue.</p>
      <h4 id="union">Union</h4>
      <p>
        The union of sets \( A \) and \( B \), denoted by the expression \( A
        \cup B \), is the set that includes exactly the elements appearing in \(
        A \) or \( B \) or both. And it could be written in
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://www.mathsisfun.com/sets/set-builder-notation.html"
          >set-builder notation</a
        >
        as:
      </p>
      <p>\[ A \cup B = \{x : x \in A \ \text{or} \ x \in B\} \]</p>
      <p>
        Let's create a <code>Union</code> method for the <code>Set</code> type
        to compute the union of two sets:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">Set</span><span>) </span><span style="color:#8fa1b3;">Union</span><span>(</span><span style="color:#bf616a;">other </span><span style="color:#b48ead;">Set</span><span>) (</span><span style="color:#bf616a;">set </span><span style="color:#b48ead;">Set</span><span>) {
</span><span>	</span><span style="color:#bf616a;">set </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>()
</span><span>
</span><span>	</span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">k </span><span>:= </span><span style="color:#b48ead;">range </span><span style="color:#bf616a;">s </span><span>{
</span><span>		</span><span style="color:#bf616a;">set</span><span>[</span><span style="color:#bf616a;">k</span><span>] = </span><span style="color:#bf616a;">membership</span><span>{}
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">k </span><span>:= </span><span style="color:#b48ead;">range </span><span style="color:#bf616a;">other </span><span>{
</span><span>		</span><span style="color:#bf616a;">set</span><span>[</span><span style="color:#bf616a;">k</span><span>] = </span><span style="color:#bf616a;">membership</span><span>{}
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#b48ead;">return
</span><span>}
</span></code></pre>
      <p>
        The result of the union of two sets \( A = \{ \text{cat}, \text{dog},
        \text{cow} \} \) and \( B = \{ \text{cat}, \text{duck}, \text{bull} \}
        \) can be expressed as \( A \cup B = \{
        \text{cat},\text{dog},\text{cow},\text{duck},\text{bull} \} \). Let's
        test our implementation:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#bf616a;">A </span><span>:= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">cow</span><span>&quot;)
</span><span style="color:#bf616a;">B </span><span>:= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">duck</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">bull</span><span>&quot;)
</span><span>
</span><span style="color:#bf616a;">U </span><span>:= </span><span style="color:#bf616a;">A</span><span>.</span><span style="color:#bf616a;">Union</span><span>(</span><span style="color:#bf616a;">B</span><span>)
</span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Println</span><span>(</span><span style="color:#bf616a;">U</span><span>.</span><span style="color:#bf616a;">ToString</span><span>())
</span><span style="color:#65737e;">// {cat,dog,cow,duck,bull}
</span></code></pre>
      <p>So far so good?</p>
      <h4 id="intersection">Intersection</h4>
      <p>
        The intersection of \( A \) and \( B \), denoted by the expression \( A
        \cap B \), is a set of all elements that appear in both \( A \) and \( B
        \). And it could be written in set-builder notation as:
      </p>
      <p>\[ A \cap B = \{x : x \in A\ \text{and} \ x \in B\} \]</p>
      <p>
        Let's implement an <code>Intersection</code> method for the
        <code>Set</code> type to yield the elements of the intersection of two
        sets:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">Set</span><span>) </span><span style="color:#8fa1b3;">Intersection</span><span>(</span><span style="color:#bf616a;">other </span><span style="color:#b48ead;">Set</span><span>) (</span><span style="color:#bf616a;">set </span><span style="color:#b48ead;">Set</span><span>) {
</span><span>	</span><span style="color:#bf616a;">set </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>()
</span><span>
</span><span>	</span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">k </span><span>:= </span><span style="color:#b48ead;">range </span><span style="color:#bf616a;">s </span><span>{
</span><span>		</span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">ok </span><span>:= </span><span style="color:#bf616a;">other</span><span>.</span><span style="color:#bf616a;">Contains</span><span>(</span><span style="color:#bf616a;">k</span><span>); </span><span style="color:#bf616a;">ok </span><span>{
</span><span>			</span><span style="color:#bf616a;">set</span><span>[</span><span style="color:#bf616a;">k</span><span>] = </span><span style="color:#bf616a;">membership</span><span>{}
</span><span>		}
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#b48ead;">return
</span><span>}
</span></code></pre>
      <p>
        The result of the intersection of the sets \( A = \{ \text{cat},
        \text{dog}, \text{cow} \} \) and \( B = \{ \text{cat}, \text{duck},
        \text{bull} \} \) can be presented as \( A \cap B = \{ \text{cat} \} \).
        In our Go code, that operation is expressed as follows:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#bf616a;">A </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">cow</span><span>&quot;)
</span><span style="color:#bf616a;">B </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">duck</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">bull</span><span>&quot;)
</span><span>
</span><span style="color:#bf616a;">I </span><span>:= </span><span style="color:#bf616a;">A</span><span>.</span><span style="color:#bf616a;">Intersection</span><span>(</span><span style="color:#bf616a;">B</span><span>)
</span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Println</span><span>(</span><span style="color:#bf616a;">I</span><span>.</span><span style="color:#bf616a;">ToString</span><span>())
</span><span style="color:#65737e;">// {cat}
</span></code></pre>
      <p>It works just as expected.</p>
      <h4 id="difference-and-complement">Difference and Complement</h4>
      <p>
        The difference of \( A \) and \( B \), or the complement of \( B \) in
        \( A \), denoted by the expression \( A \setminus B \), is a set of all
        elements that appear in \( A \) but not in \( B \). And it could be
        written in set-builder notation as:
      </p>
      <p>\[ A \setminus B = \{x : x \in A\ \text{and} \ x \notin B \} \]</p>
      <p>
        Let's write a <code>Difference</code> method for the
        <code>Set</code> type to compute the difference between two sets:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">Set</span><span>) </span><span style="color:#8fa1b3;">Difference</span><span>(</span><span style="color:#bf616a;">other </span><span style="color:#b48ead;">Set</span><span>) (</span><span style="color:#bf616a;">set </span><span style="color:#b48ead;">Set</span><span>) {
</span><span>	</span><span style="color:#bf616a;">set </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>()
</span><span>
</span><span>	</span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">k </span><span>:= </span><span style="color:#b48ead;">range </span><span style="color:#bf616a;">s </span><span>{
</span><span>		</span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">ok </span><span>:= </span><span style="color:#bf616a;">other</span><span>.</span><span style="color:#bf616a;">Contains</span><span>(</span><span style="color:#bf616a;">k</span><span>); !</span><span style="color:#bf616a;">ok </span><span>{
</span><span>			</span><span style="color:#bf616a;">set</span><span>[</span><span style="color:#bf616a;">k</span><span>] = </span><span style="color:#bf616a;">membership</span><span>{}
</span><span>		}
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#b48ead;">return
</span><span>}
</span></code></pre>
      <p>
        The result of the difference of the sets \( A = \{ \text{cat},
        \text{dog}, \text{cow} \} \) and \( B = \{ \text{cat}, \text{duck},
        \text{bull} \} \) can be written as \( A \setminus B = \{\text{dog},
        \text{cow} \} \). Let's check if our code is correct:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#bf616a;">A </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">cow</span><span>&quot;)
</span><span style="color:#bf616a;">B </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">duck</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">bull</span><span>&quot;)
</span><span>
</span><span style="color:#bf616a;">D </span><span>:= </span><span style="color:#bf616a;">A</span><span>.</span><span style="color:#bf616a;">Difference</span><span>(</span><span style="color:#bf616a;">B</span><span>)
</span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Println</span><span>(</span><span style="color:#bf616a;">D</span><span>.</span><span style="color:#bf616a;">ToString</span><span>())
</span><span style="color:#65737e;">// {dog,cow}
</span></code></pre>
      <p>Perfect!</p>
      <h4 id="symmetric-difference">Symmetric Difference</h4>
      <p>
        The symmetric difference of \( A \) and \( B \), denoted by the
        expression \( A \ominus B \), is a set of all elements that appear in \(
        A \) or in \( B \) but not in both. And it could be written in
        set-builder notation as:
      </p>
      <p>
        \[ A \ominus B = \{ x : x \in A \setminus B \text{ or} \in B \setminus A
        \} \]
      </p>
      <p>
        Let's write a <code>SymmetricDifference</code> method for the
        <code>Set</code> type to compute the symmetric difference between two
        sets:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">Set</span><span>) </span><span style="color:#8fa1b3;">SymmetricDifference</span><span>(</span><span style="color:#bf616a;">other </span><span style="color:#b48ead;">Set</span><span>) (</span><span style="color:#bf616a;">set </span><span style="color:#b48ead;">Set</span><span>) {
</span><span>	</span><span style="color:#bf616a;">set </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>()
</span><span>
</span><span>	</span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">k </span><span>:= </span><span style="color:#b48ead;">range </span><span style="color:#bf616a;">s </span><span>{
</span><span>		</span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">ok </span><span>:= </span><span style="color:#bf616a;">other</span><span>.</span><span style="color:#bf616a;">Contains</span><span>(</span><span style="color:#bf616a;">k</span><span>); !</span><span style="color:#bf616a;">ok </span><span>{
</span><span>			</span><span style="color:#bf616a;">set</span><span>[</span><span style="color:#bf616a;">k</span><span>] = </span><span style="color:#bf616a;">membership</span><span>{}
</span><span>		}
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">k </span><span>:= </span><span style="color:#b48ead;">range </span><span style="color:#bf616a;">other </span><span>{
</span><span>		</span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">ok </span><span>:= </span><span style="color:#bf616a;">s</span><span>.</span><span style="color:#bf616a;">Contains</span><span>(</span><span style="color:#bf616a;">k</span><span>); !</span><span style="color:#bf616a;">ok </span><span>{
</span><span>			</span><span style="color:#bf616a;">set</span><span>[</span><span style="color:#bf616a;">k</span><span>] = </span><span style="color:#bf616a;">membership</span><span>{}
</span><span>		}
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#b48ead;">return
</span><span>}
</span></code></pre>
      <p>
        The result of the symmetric difference of the sets \( A = \{ \text{cat},
        \text{dog}, \text{cow} \} \) and \( B = \{ \text{cat}, \text{duck},
        \text{bull} \} \) can be defined as \( A \ominus B = \{ \text{dog},
        \text{cow}, \text{duck}, \text{bull} \} \). Let's try it in our code:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#bf616a;">A </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">cow</span><span>&quot;)
</span><span style="color:#bf616a;">B </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">duck</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">bull</span><span>&quot;)
</span><span>
</span><span style="color:#bf616a;">SD </span><span>:= </span><span style="color:#bf616a;">A</span><span>.</span><span style="color:#bf616a;">SymmetricDifference</span><span>(</span><span style="color:#bf616a;">B</span><span>)
</span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Println</span><span>(</span><span style="color:#bf616a;">SD</span><span>.</span><span style="color:#bf616a;">ToString</span><span>())
</span><span style="color:#65737e;">// {dog,cow,duck,bull}
</span></code></pre>
      <p>Great!</p>
      <h4 id="subset">Subset</h4>
      <p>
        The expression \( A \subseteq B \) indicates that set \( A \) is a
        subset of set \( B \), which means every element of \( A \) is also an
        element of \( B \). It could be written in set-builder notation as:
      </p>
      <p>\[ A \subseteq B \iff A \cap B = A \]</p>
      <p>
        Let's implement a <code>SubsetOf</code> method for the
        <code>Set</code> type to assert if a given set is a subset of another
        set:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">Set</span><span>) </span><span style="color:#8fa1b3;">SubsetOf</span><span>(</span><span style="color:#bf616a;">other </span><span style="color:#b48ead;">Set</span><span>) </span><span style="color:#b48ead;">bool </span><span>{
</span><span>	</span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">s</span><span>.</span><span style="color:#bf616a;">Size</span><span>() &gt; </span><span style="color:#bf616a;">other</span><span>.</span><span style="color:#bf616a;">Size</span><span>() {
</span><span>		</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">false
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">k </span><span>:= </span><span style="color:#b48ead;">range </span><span style="color:#bf616a;">s </span><span>{
</span><span>		</span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">_</span><span>, </span><span style="color:#bf616a;">exists </span><span>:= </span><span style="color:#bf616a;">other</span><span>[</span><span style="color:#bf616a;">k</span><span>]; !</span><span style="color:#bf616a;">exists </span><span>{
</span><span>			</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">false
</span><span>		}
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true
</span><span>}
</span></code></pre>
      <p>
        For the sets \( A = \{ \text{cat}, \text{dog}, \text{cow} \} \) and \( B
        = \{ \text{cat}, \text{dog} \} \), we can assert that \( B \subseteq A
        \) is \( \text{true} \), but \( A \subseteq B \) is \( \text{false} \).
        Let's test it:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#bf616a;">A </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">cow</span><span>&quot;)
</span><span style="color:#bf616a;">B </span><span>= </span><span style="color:#bf616a;">MakeSet</span><span>(&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;)
</span><span>
</span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Println</span><span>(</span><span style="color:#bf616a;">B</span><span>.</span><span style="color:#bf616a;">SubsetOf</span><span>(</span><span style="color:#bf616a;">A</span><span>)) </span><span style="color:#65737e;">// true
</span><span style="color:#bf616a;">fmt</span><span>.</span><span style="color:#bf616a;">Println</span><span>(</span><span style="color:#bf616a;">A</span><span>.</span><span style="color:#bf616a;">SubsetOf</span><span>(</span><span style="color:#bf616a;">B</span><span>)) </span><span style="color:#65737e;">// false
</span></code></pre>
      <p>
        Mission accomplished! Due to that, we had implemented the basic set
        operations supported for sets as an abstract data type. All the code for
        this implementation can be found in this
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://gist.github.com/rodmoioliveira/65281facd4117c37957a2373c5323892"
          >gist</a
        >. Now we can get familiar with some fundamental set properties that we
        should be aware of.
      </p>
      <h3 id="set-identities">Set Identities</h3>
      <p>
        Sets have some properties that hold true for all subsets of any given
        set. These properties are called set identities and are presented down
        below. In the following examples, consider that the sets \( A \), \(
        B\), \( C \) are subsets of a universal set \( U \).
      </p>
      <h4 id="antisymmetric">Antisymmetric</h4>
      <p>
        A binary relation \(R\) on a set \(A\) is antisymmetric if there is no
        pair of distinct elements of \(A\) each of which is related by \(R\) to
        the other. More formally, \(R\) is antisymmetric precisely if:
      </p>
      <p>\[ \forall (x,y) \in A:(xRy \text{ and } yRx) \Rightarrow x = y \]</p>
      <p>For sets, the subset relation is antisymmetric:</p>
      <p>\[ A \subseteq B \text{ and } B \subseteq A \Rightarrow A = B \]</p>
      <h4 id="associative">Associative</h4>
      <p>
        Associativity is a property of some binary operations, which means that
        rearranging the parentheses in an expression will not change the result.
        Union and intersection are associative:
      </p>
      <p>
        \[ A \cup \left( {B \cup C} \right) = \left( {A \cup B} \right) \cup C
        \newline A \cap \left( {B \cap C} \right) = \left( {A \cap B} \right)
        \cap C \]
      </p>
      <h4 id="commutative">Commutative</h4>
      <p>
        A binary operation is commutative if changing the order of the operands
        does not change the result. Union and intersection are commutative:
      </p>
      <p>\[ A \cup B = B \cup A \newline A \cap B = B \cap A \]</p>
      <h4 id="complement">Complement</h4>
      <p>
        In set theory, the complement of a set \( A \), denoted by \( A^c \), is
        a set of all the elements that aren't in \( A \):
      </p>
      <p>
        \[ A \cup {A ^ c} = U \newline A \cap {A ^ c} = \varnothing \newline {U
        ^ c} = \varnothing \newline {\varnothing ^ c} = U \]
      </p>
      <h4 id="de-morgan-s-laws">De Morgan's Laws</h4>
      <p>
        De Morgan's Laws describe how mathematical statements and concepts are
        related through their opposites, which explain how to distribute
        NOT's(\(\neg\)) over AND's(\(\land\)) and OR's(\(\lor\)):
      </p>
      <p>
        \[ \neg (P \land Q) \iff (\neg P) \lor (\neg Q) \newline \neg (P \lor Q)
        \iff (\neg P) \land (\neg Q) \]
      </p>
      <p>
        In set theory, De Morgan's Laws relate the intersection and union of
        sets through complements.
      </p>
      <p>
        \[ ( A \cup B )^c = A^c \cap B^c \newline ( A \cap B )^c = A^c \cup B^c
        \]
      </p>
      <h4 id="distributive">Distributive</h4>
      <p>
        The distributive property tells us how to solve expressions in which
        more than one binary relation is involved. For example, given a set \( A
        \) and two binary operators \( * \) and \( + \) on \( A \), the
        distributive law asserts that multiplication (\( * \)) distributes over
        addition (\( + \)) in elementary arithmetic:
      </p>
      <p>\[ x * (y + z) = x * y + x * z \]</p>
      <p>For sets, intersection distributes over union and vice-versa:</p>
      <p>
        \[ A \cup \left( {B \cap C} \right) = \left( {A \cup B} \right) \cap
        \left( {A \cup C} \right) \newline A \cap \left( {B \cup C} \right) =
        \left( {A \cap B} \right) \cup \left( {A \cap C} \right) \]
      </p>
      <h4 id="double-complement">Double Complement</h4>
      <p>
        The complement of the complement of a set \( A \) is itself \( A \):
      </p>
      <p>\[ ( A^c )^c = A \]</p>
      <h4 id="idempotent">Idempotent</h4>
      <p>
        Idempotence is the property of certain operations in mathematics whereby
        they can be applied multiple times without changing the result beyond
        the initial value:
      </p>
      <p>\[ A \cup A = A \newline A \cap A = A \]</p>
      <h4 id="identity">Identity</h4>
      <p>
        The empty set (\( \varnothing \)) is an identity operand for unions, and
        the universal set (\( U \)) is the identity operand for intersections:
      </p>
      <p>\[ A \cup \varnothing = A \newline A \cap U = A \]</p>
      <h4 id="transitive">Transitive</h4>
      <p>
        In mathematics, a relation \(R\) on a set \(A\) is transitive if, for
        all elements \(a\), \(b\), \(c\) in \(A\), whenever \(R\) relates \(a\)
        to \(b\) and \(b\) to \(c\), then \(R\) also relates \(a\) to \(c\):
      </p>
      <p>\[ \forall (a,b,c) \in A:(aRb \text{ and } bRc) \Rightarrow aRc \]</p>
      <p>For sets, the subset relation is transitive:</p>
      <p>
        \[ ( A \subseteq B ) \text{ and } ( B \subseteq C ) \Rightarrow ( A
        \subseteq C ) \]
      </p>
      <h3 id="counting-bit-sequences">Counting bit sequences</h3>
      <p>
        Sets are great for counting things because we can establish relations
        between different sets, which can be useful to count infinite sets. If
        we could find these relations between countable things, we can transform
        otherwise hard problems into trivial operations. For instance, there's a
        clever way to count the number of n-bit sequences that can be yielded
        from using an n-bit unit of data. Therefore, questions like how many
        values a 64-integer type can represent are easily answered.
      </p>
      <p>
        To understand how it works, we have to comprehend the following
        mathematical concepts within set theory: <strong>cardinality</strong>,
        <strong>product of sets</strong>, <strong>power sets</strong>, and
        <strong>bijections</strong>.
      </p>
      <h4 id="cardinality">Cardinality</h4>
      <p>
        The cardinality or size of a set \(A\), denoted \(|A|\), is the number
        of elements in \(A\) when that number is finite:
      </p>
      <p>\[ A = \{0,1\} \Rightarrow |A| = 2 \]</p>
      <p>Easy enough, right?</p>
      <h4 id="product-of-sets">Product of sets</h4>
      <p>
        The cross product of two sets \(A\) and \(B\), denoted \(A \times B\),
        is the set of all ordered pairs of elements in \(A\) and elements in
        \(B\):
      </p>
      <p>\[ A \times B = \{(a,b) : a \in A \text{ and } b \in B\} \]</p>
      <p>A product of \(n\) copies of a set \(A\) is denoted \(A^n\):</p>
      <p>
        \[ A^n = \{(a_1, \cdots, a_n) : a_i \in A \text{ for every } i \} \]
      </p>
      <p>
        The cardinality of the cross product of sets is calculated by these
        rules:
      </p>
      <p>
        \[ \begin{align*} |A \times B| &amp;= |A||B| \newline |A^{n}| &amp;=
        |A|^n \end{align*} \]
      </p>
      <p>
        For example, the cross product of the sets \( A = \{a,b\} \) and \( B =
        \{1,2,3\} \), denoted \(A \times B\), is equal to:
      </p>
      <p>\[ \{ (a,1),(a,2),(a,3),(b,1),(b,2),(b,3) \} \]</p>
      <p>Which is not the same that the cross product of \( B \times A \):</p>
      <p>\[ \{ (1,a), (1,b), (2,a), (2,b), (3,a), (3,b) \} \]</p>
      <h4 id="power-set">Power Set</h4>
      <p>
        The power set of the set \(A\), denoted \( \mathcal{P}(A) \), is the set
        of all the subsets \(B\) in the set \(A\):
      </p>
      <p>\[ \mathcal{P}(A) = \{B : B \subseteq A \} \]</p>
      <p>
        Here's an example for the set \( L = \{ \text{bat}, \text{frog} \} \):
      </p>
      <p>
        \[ \mathcal{P}(L) = \{ \varnothing, \{\text{bat} \}, \{\text{frog} \},
        \{\text{bat}, \text{frog} \} \} \]
      </p>
      <p>
        The cardinality of the power sets of any given set \(A\) is defined as
        \(|\mathcal{P}(A)| = 2^{|A|}\).
      </p>
      <h4 id="bijection">Bijection</h4>
      <p>
        A bijection is a function between the elements of two sets, where each
        element of one set is paired with exactly one element of the other set.
        A bijective function mean that the sets being mapped have the same
        cardinality:
      </p>
      <p>
        \[ \text{if } f : A \rightarrow B \text{ is a bijection } \Rightarrow
        |A| = |B| \]
      </p>
      <h4 id="counting-subsets-of-a-finite-set">
        Counting subsets of a finite set
      </h4>
      <p>
        As a consequence of the bijection rule above, and the cardinalities of
        power sets and product sets, we can demonstrate that there's a bijection
        that maps the elements of \( \mathcal{P}(A) \) to elements in \(
        \{0,1\}^n \), the product set of n-bit sequences. More formally, we want
        to prove that power sets and product sets have the same cardinality:
      </p>
      <p>\[ |A| = n \implies | \mathcal{P}(A) | = | \{0,1\}^n | = 2^{n} \]</p>
      <p>And that there's a bijection between them:</p>
      <p>\[ \mathcal{P}(A) \text{ bij } \{0,1\}^n \]</p>
      <p>
        \( \text{Prove:} \) Let \( a_1,a_2, \cdots, a_n \) be the elements of \(
        A \). The bijection that maps each subset of \( S \subseteq A \) to the
        bit sequence \( (b_1, \cdots, b_n) \) is defined by the rule:
      </p>
      <p>\[\tag{1.0} a_i \in S \iff b_i = 1\]</p>
      <p>
        Therefore, if \(n = 3\), then the subset \(\{a_2,a_3\} \subseteq A \)
        maps to a 3-bit sequence as follows:
      </p>
      <p>
        \[ \begin{aligned} a_1 \notin \{ a_2,a_3 \} \iff b_1 = 0 \newline a_2
        \in \{ a_2,a_3 \} \iff b_2 = 1 \newline a_3 \in \{ a_2,a_3 \} \iff b_3 =
        1 \newline \end{aligned} \]
      </p>
      <p>
        In fact, all subsets \( S \subseteq A \) can be mapped to a 3-bit
        sequence using the rule \((1.0)\) as follows:
      </p>
      <table>
        <thead>
          <tr>
            <th></th>
            <th>\(\mathcal{P}(A)\)</th>
            <th>\( \{0,1\}^3 \)</th>
            <th>\(\text{binary}\)</th>
            <th>\(\text{decimal}\)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>\(1\)</td>
            <td>\( \varnothing \)</td>
            <td>\( (0,0,0) \)</td>
            <td>\( 000_2 \)</td>
            <td>\(0_{10}\)</td>
          </tr>
          <tr>
            <td>\(2\)</td>
            <td>\(\{a_3\}\)</td>
            <td>\( (0,0,1) \)</td>
            <td>\( 001_2 \)</td>
            <td>\(1_{10}\)</td>
          </tr>
          <tr>
            <td>\(3\)</td>
            <td>\(\{a_2\}\)</td>
            <td>\( (0,1,0) \)</td>
            <td>\( 010_2 \)</td>
            <td>\(2_{10}\)</td>
          </tr>
          <tr>
            <td>\(4\)</td>
            <td>\(\{a_2,a_3\}\)</td>
            <td>\( (0,1,1) \)</td>
            <td>\( 011_2 \)</td>
            <td>\(3_{10}\)</td>
          </tr>
          <tr>
            <td>\(5\)</td>
            <td>\(\{a_1\}\)</td>
            <td>\( (1,0,0) \)</td>
            <td>\( 100_2 \)</td>
            <td>\(4_{10}\)</td>
          </tr>
          <tr>
            <td>\(6\)</td>
            <td>\(\{a_1,a_3\}\)</td>
            <td>\( (1,0,1) \)</td>
            <td>\( 101_2 \)</td>
            <td>\(5_{10}\)</td>
          </tr>
          <tr>
            <td>\(7\)</td>
            <td>\(\{a_1,a_2\}\)</td>
            <td>\( (1,1,0) \)</td>
            <td>\( 110_2 \)</td>
            <td>\(6_{10}\)</td>
          </tr>
          <tr>
            <td>\(8\)</td>
            <td>\(\{a_1,a_2,a_3\}\)</td>
            <td>\( (1,1,1) \)</td>
            <td>\( 111_2 \)</td>
            <td>\(7_{10}\)</td>
          </tr>
        </tbody>
      </table>
      <p>
        As you can see, both sets \( \mathcal{P}(A) \) and \( \{0,1\}^n \) have
        the same cardinality, which is \(8\). More importantly, we'd
        demonstrated that there's a bijection between them, because each element
        of \( \mathcal{P}(A) \) is paired with exactly one element of \(
        \{0,1\}^n \). \(\blacksquare \)
      </p>
      <p>
        With this knowledge, it's very easy to count the number of values that
        can be represented by any given n-bit integer type in Golang:
      </p>
      <table>
        <thead>
          <tr>
            <th>\(\text{type}\)</th>
            <th>\( | \{0,1\}^n | \)</th>
            <th>\(\text{n-bit sequences}\)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>\(\text{int8} \)</td>
            <td>\( 2^8 \)</td>
            <td>\( 256 \)</td>
          </tr>
          <tr>
            <td>\(\text{int16} \)</td>
            <td>\( 2^{16} \)</td>
            <td>\( 65536\)</td>
          </tr>
          <tr>
            <td>\(\text{int32} \)</td>
            <td>\( 2^{32} \)</td>
            <td>\( 4294967296 \)</td>
          </tr>
          <tr>
            <td>\(\text{int64} \)</td>
            <td>\( 2^{64} \)</td>
            <td>\( 1.8446744e+19 \)</td>
          </tr>
        </tbody>
      </table>
      <p>
        It's precisely in this bijection, between product sets and power sets,
        that we rely on when we use a bit set data structure in ours programs.
      </p>
      <h4 id="bit-sets">Bit sets</h4>
      <p>
        A bit set is just an n-bit vector in which the \(\text{nth}\) byte
        represents if any given \(\text{nth}\) elements it's presented in the
        set. Bit sets can be used in Golang with
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://yourbasic.org/golang/bitwise-operator-cheat-sheet/"
          >bitwise operators</a
        >
        to execute several set operations. To see them in action, we'll propose
        a simple problem.
      </p>
      <h4 id="working-together">Working together</h4>
      <p>
        Let's suppose that we have \(n\) workers within a company, and we would
        like to know:
        <em
          >for any two workers, how many days of the week do they work
          together?</em
        >
        This problem can be easily solved using bit sets. Before we start, for
        clarity's sake, let's depict the problem mathematically. First, let's
        define a set \(W\) whose elements, \( w_1, w_2, \cdots, w_i\), represent
        days of the week:
      </p>
      <p>
        \[ \begin{align*} W &amp;= \{ \ w_1, \ w_2,\ w_3,\ w_4,\ w_5,\ w_6,\ w_7
        \} \ \ \newline &amp;= \{
        \text{sun},\text{mon},\text{tue},\text{wed},\text{thu},\text{fri},\text{sat}
        \} \end{align*} \]
      </p>
      <p>
        The power set of \(W\), denoted \( \mathcal{P}(W) \), is the set of all
        possible subsets of \(W\). Let \( \mathcal{P}(W) \) be our schedule set,
        which contains all possible sequences of work schedules that a worker
        might take in a week. What's the cardinality of \( \mathcal{P}(W) ?\)
        The answer is:
      </p>
      <p>
        \[ |W| = 7 \ \ \text{ implies } \ \ | \mathcal{P}(W) | = 2^7 = 128 \]
      </p>
      <p>
        We have \(128\) possible working schedules in our schedule set \(
        \mathcal{P}(W) \), and it one of them can be encoded as a 7-bit
        sequence. The rule for encoding each one of the subsets \(S \subseteq W
        \) to a sequence \((d_1, \cdots, d_7)\) is defined by:
      </p>
      <p>\[ w_i \in S \iff d_i = 1 \]</p>
      <p>
        Let's construct the bit sequence for the subset \( \varnothing \subseteq
        W \):
      </p>
      <p>
        \[ w_1 \notin \varnothing \iff d_1 = 0 \newline w_2 \notin \varnothing
        \iff d_2 = 0 \newline w_3 \notin \varnothing \iff d_3 = 0 \newline w_4
        \notin \varnothing \iff d_4 = 0 \newline w_5 \notin \varnothing \iff d_5
        = 0 \newline w_6 \notin \varnothing \iff d_6 = 0 \newline w_7 \notin
        \varnothing \iff d_7 = 0 \]
      </p>
      <p>
        The bit sequence for \( \varnothing \) is \( (0,0,0,0,0,0,0) \). Let's
        try another one: how about the bit sequence of the subset \( \{
        \text{mon},\text{tue},\text{thu} \} \subseteq W \)?
      </p>
      <p>
        \[ w_1 \notin \{ \text{mon},\text{tue},\text{thu} \} \iff d_1 = 0
        \newline w_2 \in \{ \text{mon},\text{tue},\text{thu} \} \iff d_2 = 1
        \newline w_3 \in \{ \text{mon},\text{tue},\text{thu} \} \iff d_3 = 1
        \newline w_4 \notin \{ \text{mon},\text{tue},\text{thu} \} \iff d_4 = 0
        \newline w_5 \in \{ \text{mon},\text{tue},\text{thu} \} \iff d_5 = 1
        \newline w_6 \notin \{ \text{mon},\text{tue},\text{thu} \} \iff d_6 = 0
        \newline w_7 \notin \{ \text{mon},\text{tue},\text{thu} \} \iff d_7 = 0
        \]
      </p>
      <p>
        The bit-sequence for the subset \( \{ \text{mon},\text{tue},\text{thu}
        \} \subseteq W \) is \( (0,1,1,0,1,0,0) \). As you can see, the bit
        sequence representation of the working schedules is really convenient.
        Hence, we can use them to encode the working schedule of all \(n\)
        workers within the company.
      </p>
      <p>
        Bit sequences can be easily construct in Golang using the
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://golang.org/ref/spec#Iota"
          >iota constant generator</a
        >. Let's begin by creating bit sequences for all the subsets \( S
        \subseteq W\) whose cardinalities are equal to \(1\). In other words,
        let's create bit sequences for all the working schedules that have just
        one day:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#b48ead;">package </span><span style="color:#bf616a;">main
</span><span>
</span><span style="color:#b48ead;">import </span><span>(
</span><span>	&quot;</span><span style="color:#a3be8c;">fmt</span><span>&quot;
</span><span>	&quot;</span><span style="color:#a3be8c;">math/bits</span><span>&quot;
</span><span>)
</span><span>
</span><span style="color:#b48ead;">const </span><span>(
</span><span>	</span><span style="color:#bf616a;">sat </span><span style="color:#b48ead;">uint8 </span><span>= </span><span style="color:#d08770;">1 </span><span>&lt;&lt; </span><span style="color:#d08770;">iota </span><span style="color:#65737e;">// (0b00000001) -&gt; {sat}
</span><span>	</span><span style="color:#bf616a;">fri                   </span><span style="color:#65737e;">// (0b00000010) -&gt; {fri}
</span><span>	</span><span style="color:#bf616a;">thu                   </span><span style="color:#65737e;">// (0b00000100) -&gt; {thu}
</span><span>	</span><span style="color:#bf616a;">wed                   </span><span style="color:#65737e;">// (0b00001000) -&gt; {wed}
</span><span>	</span><span style="color:#bf616a;">tue                   </span><span style="color:#65737e;">// (0b00010000) -&gt; {tue}
</span><span>	</span><span style="color:#bf616a;">mon                   </span><span style="color:#65737e;">// (0b00100000) -&gt; {mon}
</span><span>	</span><span style="color:#bf616a;">sun                   </span><span style="color:#65737e;">// (0b01000000) -&gt; {sun}
</span><span>)
</span></code></pre>
      <p>
        We have used the
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://golang.org/ref/spec#Iota"
          >iota constant generator</a
        >
        with the binary <em>shift left</em> operator <code>&lt;&lt;</code> to
        create seven bit sets. Notice that the operation
        <code>x &lt;&lt; k</code> consists in shifting the bytes of \(x\) by
        \(k\) bits, dropping off the \(k\) most significant bits and then
        filling the right end with \(k\) zeros. Down below, we present a
        detailed table of the binary <em>shift left</em> operation. The
        <strong>bolded digits</strong> indicate the values that were dropped
        from the left end, and <em>italicized digits</em> indicate the values
        that were filled from the right end:
      </p>
      <table>
        <thead>
          <tr>
            <th>operation</th>
            <th>input</th>
            <th>output</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>x &lt;&lt; \( 0 \)</td>
            <td>\( 00000001 \)</td>
            <td>\( 00000001 \)</td>
          </tr>
          <tr>
            <td>x &lt;&lt; \( 1 \)</td>
            <td>\( \textbf{0}0000001 \)</td>
            <td>\( 0000001\textit{0} \)</td>
          </tr>
          <tr>
            <td>x &lt;&lt; \( 2 \)</td>
            <td>\( \textbf{00}000001 \)</td>
            <td>\( 000001\textit{00} \)</td>
          </tr>
          <tr>
            <td>x &lt;&lt; \( 3 \)</td>
            <td>\( \textbf{000}00001 \)</td>
            <td>\( 00001\textit{000} \)</td>
          </tr>
          <tr>
            <td>x &lt;&lt; \( 4 \)</td>
            <td>\( \textbf{0000}0001 \)</td>
            <td>\( 0001\textit{0000} \)</td>
          </tr>
          <tr>
            <td>x &lt;&lt; \( 5 \)</td>
            <td>\( \textbf{00000}001 \)</td>
            <td>\( 001\textit{00000} \)</td>
          </tr>
          <tr>
            <td>x &lt;&lt; \( 6 \)</td>
            <td>\( \textbf{000000}01 \)</td>
            <td>\( 01\textit{000000} \)</td>
          </tr>
        </tbody>
      </table>
      <p>
        So, now that we've created all the bit sequences for the working
        schedules with a single day, we can unite them to create some working
        schedules for our workers. Take Bob and Alice, for example. They just
        returned from vacation and must choose the days they're going to work
        this week. Fortunately, the company they work for is highly flexible
        about working schedules, which is great, isn't it? So Bob decides to
        work four days this week: <em>Sunday</em>, <em>Tuesday</em>,
        <em>Friday</em>, and <em>Saturday</em>. And Alice decides to begin with
        a three-day working schedule: <em>Tuesday</em>, <em>Tuesday</em>, and
        <em>Saturday</em>. Both workers can have theirs working schedules
        represented as a set:
      </p>
      <p>
        \[ \begin{align*} \text{Bob} &amp;= \{ \text{sun} \} \cup \{ \text{thu}
        \} \cup \{ \text{fri} \} \cup \{ \text{sat} \} \newline \text{Alice}
        &amp;= \{ \text{tue} \} \cup \{ \text{thu} \} \cup \{ \text{sat} \}
        \end{align*} \]
      </p>
      <p>
        Well, let's implement that. We'll create two variables
        <code>bob</code> and <code>alice</code> and use the binary
        <em>or</em> operator <code>|</code> to union the working days of each
        one of them in a bit set:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#bf616a;">bob </span><span>:= </span><span style="color:#bf616a;">sun </span><span>| </span><span style="color:#bf616a;">thu </span><span>| </span><span style="color:#bf616a;">fri </span><span>| </span><span style="color:#bf616a;">sat </span><span style="color:#65737e;">// (0b01000111)
</span><span style="color:#bf616a;">alice </span><span>:= </span><span style="color:#bf616a;">tue </span><span>| </span><span style="color:#bf616a;">thu </span><span>| </span><span style="color:#bf616a;">sat     </span><span style="color:#65737e;">// (0b00010101)
</span></code></pre>
      <p>
        Great! The bit sequence for Bob is \( ( 1,0,0,0,1,1,1 ) \) which
        represent the set \( \{ \text{sun}, \text{thu}, \text{fri}, \text{sat}
        \} \). For Alice, the bit sequence is \( (0,0,1,0,1,0,1) \) which maps
        to the set \( \{ \text{tue}, \text{thu}, \text{sat} \} \). Now we've to
        know how many days they work together. To answer that, we must intersect
        both sets, like this:
      </p>
      <p>\[ \text{Bob} \cap \text{Alice} = \{ \text{thu}, \text{sat} \} \]</p>
      <p>
        How might we do that within our code? We have to use the binary
        <em>and</em> operator <code>&amp;</code> to intersect the two sets:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#bf616a;">daysWorkingTogether </span><span>:= </span><span style="color:#bf616a;">alice </span><span>&amp; </span><span style="color:#bf616a;">bob </span><span style="color:#65737e;">// (0b00000101)
</span></code></pre>
      <p>
        Perfect! The bit sequence \( (0,0,0,0,1,0,1) \) stands for the set \( \{
        \text{thu}, \text{sat} \} \). Finally, to get the cardinality of the bit
        set <code>daysWorkingTogether</code>, we need to calculate its
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://en.wikipedia.org/wiki/Hamming_weight"
          >hamming weight</a
        >. Which, in this case, means counting how many ones exist within the
        bit set. To do that, we can use the function
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://pkg.go.dev/math/bits#OnesCount"
          >OnesCount</a
        >
        from the package
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://pkg.go.dev/math/bits"
          >math/bits</a
        >
        package:
      </p>
      <pre
        data-lang="go"
        style="background-color: #2b303b; color: #c0c5ce"
        class="language-go"
      ><code class="language-go" data-lang="go"><span style="color:#bf616a;">cardinality </span><span>:= </span><span style="color:#bf616a;">bits</span><span>.</span><span style="color:#bf616a;">OnesCount8</span><span>(</span><span style="color:#bf616a;">daysWorkingTogether</span><span>) </span><span style="color:#65737e;">// 2
</span></code></pre>
      <p>
        Great work! Bob and Alice work two days together. Go, team! If you are
        interested in the code for the working together problem, it's in this
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://gist.github.com/rodmoioliveira/ac0cf7e41aca59c83cce4b4f8f1efe76"
          >gist</a
        >.
      </p>
      <p>
        To sum up, sets are the build blocks of mathematics and constitute an
        essential data structure to understand when writing computer programs.
        Sets provide an efficient way to test for membership and to compute the
        union and intersection of groups of objects. Also, they support several
        different implementations, such as maps, bit vectors, and
        <a
          rel="noopener nofollow noreferrer"
          target="_blank"
          href="https://en.wikipedia.org/wiki/Bloom_filter"
          >bloom filters</a
        >.
      </p>
      <h3 id="references">References</h3>

      <ul class="reference__ul">
        <li class="reference__li" id="math24:cartesian-product-of-sets">
          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;math24.net&#x2F;cartesian-product-sets.html"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Cartesian Product of Sets</a
          >.

          <span class="reference__jornal">Math24.</span>

          <span class="reference__urldate">Accessed: 2021-11-17.</span>
        </li>

        <li class="reference__li" id="mathsisfun.com:complement-set-definition">
          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;www.mathsisfun.com&#x2F;definitions&#x2F;complement-set-.html"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Complement Set Definition</a
          >.

          <span class="reference__jornal">Math is Fun.</span>

          <span class="reference__urldate">Accessed: 2021-11-17.</span>
        </li>

        <li class="reference__li" id="brilliant.org:de-morgans-laws">
          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;brilliant.org&#x2F;wiki&#x2F;de-morgans-laws&#x2F;"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >De Morgan&#x27;s Laws</a
          >.

          <span class="reference__jornal">Brilliant.org.</span>

          <span class="reference__urldate">Accessed: 2021-11-17.</span>
        </li>

        <li
          class="reference__li"
          id="mathsisfun.com:injective-surjective-bijective"
        >
          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;www.mathsisfun.com&#x2F;sets&#x2F;injective-surjective-bijective.html"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Injective, Surjective and Bijective</a
          >.

          <span class="reference__jornal">Math is Fun.</span>

          <span class="reference__urldate">Accessed: 2021-11-17.</span>
        </li>

        <li class="reference__li" id="mathsisfun.com:power-set">
          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;www.mathsisfun.com&#x2F;sets&#x2F;power-set.html"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Power Set</a
          >.

          <span class="reference__jornal">Math is Fun.</span>

          <span class="reference__urldate">Accessed: 2021-11-17.</span>
        </li>

        <li class="reference__li" id="mathsisfun.com:set-builder-notation">
          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;www.mathsisfun.com&#x2F;sets&#x2F;set-builder-notation.html"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Set-Builder Notation</a
          >.

          <span class="reference__jornal">Math is Fun.</span>

          <span class="reference__urldate">Accessed: 2021-11-17.</span>
        </li>

        <li class="reference__li" id="RandalHallaron2015">
          <span class="reference__author"
            >Bryant, Randal E; O&#x27;Hallaron, David R.</span
          >

          <span class="reference__year">(2015).</span>

          <a
            class="reference__url"
            href="http:&#x2F;&#x2F;csapp.cs.cmu.edu&#x2F;3e&#x2F;home.html"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Computer Systems: A Programmer&#x27;s Perspective</a
          >.

          <span class="reference__publisher">Pearson.</span>
        </li>

        <li class="reference__li" id="Gersting2002">
          <span class="reference__author">Gersting, Judith L.</span>

          <span class="reference__year">(2002).</span>

          <span>Mathematical Structures for Computer Science</span>.

          <span class="reference__publisher">W. H. Freeman and Company.</span>
        </li>

        <li class="reference__li" id="GoogleMathBits">
          <span class="reference__author">Google.</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;math&#x2F;bits"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >math&#x2F;bits</a
          >.

          <span class="reference__jornal">pkg.go.dev.</span>

          <span class="reference__urldate">Accessed: 2021-11-22.</span>
        </li>

        <li class="reference__li" id="Kun2018">
          <span class="reference__author">Kun, Jeremy.</span>

          <span class="reference__year">(2018).</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;jeremykun.com&#x2F;2018&#x2F;12&#x2F;01&#x2F;a-programmers-introduction-to-mathematics&#x2F;"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >A Programmer&#x27;s Introduction to Mathematics</a
          >.

          <span class="reference__publisher"
            >CreateSpace Independent Publishing Platform.</span
          >
        </li>

        <li class="reference__li" id="Lehman2010">
          <span class="reference__author"
            >Lehman, E; Leighton, T; Meyer, Albert R.</span
          >

          <span class="reference__year">(2017).</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;courses.csail.mit.edu&#x2F;6.042&#x2F;spring17&#x2F;mcs.pdf"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Mathematics for computer science</a
          >.

          <span class="reference__urldate">Accessed: 2021-11-17.</span>
        </li>

        <li class="reference__li" id="Lehman2018">
          <span class="reference__author">Lehman, Landon.</span>

          <span class="reference__year">(2018).</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;www.landonlehman.com&#x2F;post&#x2F;symmetric-difference&#x2F;"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Symmetric Difference</a
          >.

          <span class="reference__urldate">Accessed: 2021-11-17.</span>
        </li>

        <li class="reference__li" id="Basicset35:online">
          <span class="reference__author">Mói, Rodolfo.</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;gist.github.com&#x2F;rodmoioliveira&#x2F;65281facd4117c37957a2373c5323892"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Basic set operations in Golang</a
          >.

          <span class="reference__jornal">GitHub.</span>

          <span class="reference__note">2021-11-19.</span>
        </li>

        <li class="reference__li" id="Bitssets35:online">
          <span class="reference__author">Mói, Rodolfo.</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;gist.github.com&#x2F;rodmoioliveira&#x2F;ac0cf7e41aca59c83cce4b4f8f1efe76"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Bit sets in Golang</a
          >.

          <span class="reference__jornal">GitHub.</span>

          <span class="reference__note">2021-11-19.</span>
        </li>

        <li
          class="reference__li"
          id="yourbasic.com:bitwise-operators-cheat-sheet"
        >
          <span class="reference__author">Nilsson, Stefan.</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;yourbasic.org&#x2F;golang&#x2F;bitwise-operator-cheat-sheet&#x2F;"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Bitwise operators cheat sheet</a
          >.

          <span class="reference__urldate">Accessed: 2021-11-19.</span>
        </li>

        <li class="reference__li" id="Skienna08">
          <span class="reference__author">Skiena, Steven S.</span>

          <span class="reference__year">(2008).</span>

          <span>The Algorithm Design Manual</span>.

          <span class="reference__publisher">Springer.</span>
        </li>

        <li class="reference__li" id="youtube:discret-math-1">
          <span class="reference__author">TrevTutor,</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PLDDGPdw7e6Ag1EIznZ-m-qXu4XX3A0cIz"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Discrete Math 1</a
          >.

          <span class="reference__organization">Youtube.</span>

          <span class="reference__urldate">Accessed: 2021-11-19.</span>
        </li>

        <li class="reference__li" id="youtube:discret-math-2">
          <span class="reference__author">TrevTutor,</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PLDDGPdw7e6Aj0amDsYInT_8p6xTSTGEi2"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Discrete Math 2</a
          >.

          <span class="reference__organization">Youtube.</span>

          <span class="reference__urldate">Accessed: 2021-11-19.</span>
        </li>

        <li class="reference__li" id="WikipediaAlgebraOfSets">
          <span class="reference__author">Wikipedia.</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Algebra_of_sets"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Algebra of sets</a
          >.

          <span class="reference__urldate">Accessed: 2021-11-05.</span>
        </li>

        <li class="reference__li" id="WikipediaBloomFilter">
          <span class="reference__author">Wikipedia.</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bloom_filter"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Bloom filter</a
          >.

          <span class="reference__urldate">Accessed: 2021-11-23.</span>
        </li>

        <li class="reference__li" id="WikipediaHammingWeight">
          <span class="reference__author">Wikipedia.</span>

          <a
            class="reference__url"
            href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hamming_weight"
            rel="noopener nofollow noreferrer"
            target="_blank"
            >Hamming weight</a
          >.

          <span class="reference__urldate">Accessed: 2021-11-22.</span>
        </li>
      </ul>

      <p class="mark__end">&smashp;</p>
    </article>

    <script
      defer
      src="/webfontloader@1.6.28/webfontloader.js"
      integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc="
      crossorigin="anonymous"
    ></script>

    <script>
      window.WebFontConfig = {
        custom: {
          families: [
            "KaTeX_AMS",
            "KaTeX_Caligraphic:n4,n7",
            "KaTeX_Fraktur:n4,n7",
            "KaTeX_Main:n4,n7,i4,i7",
            "KaTeX_Math:i4,i7",
            "KaTeX_Script",
            "KaTeX_SansSerif:n4,n7,i4",
            "KaTeX_Size1",
            "KaTeX_Size2",
            "KaTeX_Size3",
            "KaTeX_Size4",
            "KaTeX_Typewriter",
          ],
        },
      };
    </script>

    <script
      defer
      src="/katex/katex.min.js"
      integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
      crossorigin="anonymous"
    ></script>

    <script
      defer
      src="/katex/contrib/copy-tex.min.js"
      integrity="sha384-Ep9Es0VCjVn9dFeaN2uQxgGcGmG+pfZ4eBaHxUpxXDORrrVACZVOpywyzvFRGbmv"
      crossorigin="anonymous"
    ></script>

    <script
      defer
      src="/katex/contrib/auto-render.min.js"
      integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
      crossorigin="anonymous"
      onload="renderMathInElement(document.body);"
    ></script>

    <nav class="nav">
      <ul class="nav__ul">
        <li class="nav__li">
          <a class="nav__link" href="/blog">blog</a>
        </li>
        <li class="nav__li">
          <a class="nav__link" href="/bookmarks">bookmarks</a>
        </li>
        <li class="nav__li">
          <a class="nav__link" href="/work">work</a>
        </li>
      </ul>
    </nav>

    <footer class="footer">
      <ul class="footer__ul">
        <li class="footer__li">
          <a
            target="_blank"
            rel="noopener noreferrer"
            class="footer__link"
            href="https://www.linkedin.com/in/rodmoi/"
            >linkedin</a
          >
        </li>
        <li class="footer__li">
          <a
            target="_blank"
            rel="noopener noreferrer"
            class="footer__link"
            href="https://github.com/rodmoioliveira"
            >github</a
          >
        </li>
        <li class="footer__li">
          <a
            target="_blank"
            rel="noopener noreferrer"
            class="footer__link"
            href="https://twitter.com/rodmoi"
            >twitter</a
          >
        </li>
      </ul>
    </footer>

    <script type="text/javascript" src="/scripts/script.js"></script>
  </body>
</html>
