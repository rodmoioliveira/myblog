<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1"
    />
    <meta name="keywords" content="blog, blogs, programming" />
    <meta name="description" content="Rodolfo Mói personal website." />
    <meta name="language" content="en-US" />
    <meta
      name="author"
      content="Rodolfo Mói, rodmoi.oliveira@gmail.com"
    />
    <meta name="designer" content="Rodolfo Mói" />
    <meta name="copyright" content="Rodolfo Mói" />
    <meta name="reply-to" content="rodmoi.oliveira@gmail.com" />
    <meta name="owner" content="Rodolfo Mói" />
    <meta
      name="url"
      content="https://rm-o.netlify.app/"
    />
    <meta
      name="identifier-URL"
      content="https://rm-o.netlify.app/"
    />
    <meta name="coverage" content="Worldwide" />
    <meta name="distribution" content="Global" />
    <meta name="rating" content="General" />
    <meta http-equiv="Expires" content="0" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Cache-Control" content="no-cache" />
    <meta
      http-equiv="Content-Type"
      content="text/html; charset=UTF-8"
    />
    <title>Summarizing huge amounts of logs</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=PT+Mono&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/style.css" media="all" />
  </head>
  <body id="body" data-theme="light">
    <header class="header">
      <h1 class="header__title">
        <a class="header__link" href="/">rm-o</a>
      </h1>
      <button class="header__btn" id="theme">dark</button>
    </header>

    <script>
      const theme = localStorage.getItem('rodolfo-blog-theme');
      if (theme === 'dark') {
        const btn = document.getElementById('theme');
        const body = document.getElementById('body');
        body.setAttribute('data-theme', 'dark');
        btn.innerText = 'light';
      }
    </script>

    
    <article class="post">
        <h2 class="post__title">Summarizing huge amounts of logs</h2>
        <p class="post__date">2021-11-01</p>
        <p>Here at <a rel="noopener nofollow noreferrer" target="_blank" href="https://www.americanas.com.br/">americanas s.a.</a> we've been getting
ready for the biggest e-commerce event of the year: <a rel="noopener nofollow noreferrer" target="_blank" href="https://en.wikipedia.org/wiki/Black_Friday_(shopping)">Black
Friday</a>. For the last two
months or so, we've been testing the resilience and scalability of ours
microservices. Usually, tests happen once a week, from one day to the other, and
it takes about 2 hours to finish.</p>
<p>As a member of the catalog team, we are responsible for several applications,
including a Graphql server in Golang that service over 3.5M requests for a
minute in days with very high traffic. Our main task on these workload tests is
to check the application's metrics to spot, report, and resolve performance
issues. We also store data for posterior analysis, like throughput, response
time distributions, Kubernetes CPU usages, etc. For the most part, we have good
instrumentation to gather all the business and technical information that is
critical to us.</p>
<h3 id="missing-metrics">Missing metrics</h3>
<p>Nevertheless, a problem has arisen at the beginning of our last test. Our
application - let's call it <code>moonapi</code> - received an additional 1M requests per
minute compared to the previous test. That was strange because the workload
settings remained the same as last time. We started to investigate the problem
and sought clues in ours telemetry tools to find the reason for this increase.</p>
<p>My manager had a hunch. The increase in the throughput had occurred because the
frontend had requested new content from the <code> moonapi</code>. To test his hypotheses,
we have to find a way to check what positions the frontend was calling. Just to
put it in context, this is how the <code>moonapi</code> works:</p>
<pre data-lang="txt" style="background-color:#2b303b;color:#c0c5ce;" class="language-txt "><code class="language-txt" data-lang="txt"><span>Schema:
</span><span>/moonapi/:route/:platform/:position/:brand/:sitepage
</span><span>
</span><span>Resource:    Possible Values:
</span><span>:route       position|positions|curaded-list
</span><span>:platform    mobile|desktop|app
</span><span>:position    contenttop1|page-config|...
</span><span>:brand       americanas|submarino|soubarato|shoptime
</span><span>:sitepage    produto/moda/calcados
</span><span>
</span><span>Example:
</span><span>curl https://moonapi/publication/desktop/page-config/americanas/produto/moda
</span></code></pre>
<p>Unfortunately, the telemetry tool hadn't been instrumented at that time to
collect data about the platforms or positions most accessed. This data was not
accessible from either Datadog or Kibana dashboards. We'd to find another way of
getting this information. Luckily, we had the logs from the API requests flowing
in our pod's instances at AWS EC2. And I could easily access them via <code>kubectl</code>
command. My first idea was to pipe these logs into a file:</p>
<pre data-lang="sh" style="background-color:#2b303b;color:#c0c5ce;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#65737e;"># https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#logs
</span><span style="color:#bf616a;">kubectl</span><span> logs</span><span style="color:#bf616a;"> -n</span><span> moon-namespace \
</span><span style="color:#bf616a;">    -l</span><span> app=moonapi \
</span><span style="color:#bf616a;">    --max-log-requests</span><span> 230</span><span style="color:#bf616a;"> -f </span><span>&gt; moon_logs
</span></code></pre>
<p>After just one minute, I collected 618Mb of logs from the <code>moonapi</code>. Then I ran
the <code>wc</code> command to count the entries: 2.5M. That was a lot!</p>
<pre data-lang="sh" style="background-color:#2b303b;color:#c0c5ce;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#bf616a;">wc -l</span><span> moon_logs
</span><span> </span><span style="color:#bf616a;">2487232</span><span> moon_logs
</span></code></pre>
<p>Here is an example of the kind of information that was available within the
logs. I removed some keys for security reasons:</p>
<pre data-lang="sh" style="background-color:#2b303b;color:#c0c5ce;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#bf616a;">head -n</span><span> 1 moon_logs | </span><span style="color:#bf616a;">jq
</span><span>
</span><span>{
</span><span>  &quot;</span><span style="color:#a3be8c;">duration</span><span>&quot;</span><span style="color:#bf616a;">:</span><span> 1,
</span><span>  &quot;</span><span style="color:#a3be8c;">level</span><span>&quot;</span><span style="color:#bf616a;">: </span><span>&quot;</span><span style="color:#a3be8c;">info</span><span>&quot;,
</span><span>  &quot;</span><span style="color:#a3be8c;">msg</span><span>&quot;</span><span style="color:#bf616a;">: </span><span>&quot;</span><span style="color:#a3be8c;">OK</span><span>&quot;,
</span><span>  &quot;</span><span style="color:#a3be8c;">path</span><span>&quot;</span><span style="color:#bf616a;">: </span><span>&quot;</span><span style="color:#a3be8c;">/moonapi/publication/desktop/blackbox/americanas/produto/utilidades-domesticas/lavanderia/varal</span><span>&quot;,
</span><span>  &quot;</span><span style="color:#a3be8c;">status</span><span>&quot;</span><span style="color:#bf616a;">:</span><span> 200,
</span><span>  &quot;</span><span style="color:#a3be8c;">time</span><span>&quot;</span><span style="color:#bf616a;">: </span><span>&quot;</span><span style="color:#a3be8c;">2021-10-23T06:30:04Z</span><span>&quot;
</span><span>}
</span></code></pre>
<p>I had a sample of one minute with 2.5M log entries. Each log entry had the <code>path</code>
that the frontend had requested. I just needed to do some data manipulations to
get the answer that we were looking for.</p>
<h3 id="finding-the-path">Finding the path</h3>

    </article>


    <nav class="nav">
      <ul class="nav__ul">
        <li class="nav__li">
          <a class="nav__link" href="/blog">blog</a>
        </li>
        <li class="nav__li">
          <a class="nav__link" href="/bookmarks">bookmarks</a>
        </li>
        <li class="nav__li">
          <a class="nav__link" href="/work">work</a>
        </li>
      </ul>
    </nav>
    <footer class="footer">
      <ul class="footer__ul">
        <li class="footer__li">
          <a
            target="_blank"
            rel="noopener noreferrer"
            class="footer__link"
            href="https://www.linkedin.com/in/rodmoi/"
            >linkedin</a
          >
        </li>
        <li class="footer__li">
          <a
            target="_blank"
            rel="noopener noreferrer"
            class="footer__link"
            href="https://github.com/rodmoioliveira"
            >github</a
          >
        </li>
        <li class="footer__li">
          <a
            target="_blank"
            rel="noopener noreferrer"
            class="footer__link"
            href="https://twitter.com/rodmoi"
            >twitter</a
          >
        </li>
      </ul>
    </footer>
    <script type="text/javascript" src="/script.js"></script>
  </body>
</html>
